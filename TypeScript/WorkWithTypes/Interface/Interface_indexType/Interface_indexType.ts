// В TypeScript ⁡⁢⁣⁣индексируемые типы⁡ позволяют определить типы для доступа к элементам объекта через ⁡⁣⁣⁢индекс⁡, 
// который может быть ⁡⁣⁣⁢строкой⁡ или ⁡⁣⁣⁢числом⁡. Это удобно, когда вы работаете с ⁡⁢⁣⁣объектами⁡, 
// которые имеют ⁡⁣⁣⁢динамические свойства⁡, и вы не знаете их точное ⁡⁣⁣⁢количество⁡ или ⁡⁣⁣⁢имена⁡ заранее.

// Существует ​‌‍‌⁡⁣⁣⁢два типа⁡​ индексации типов /

// ⁡⁢⁣⁣Индексируемые свойства⁡ (Indexed Properties):
// ⁡⁢⁣⁣Строковые индексы⁡: Можно использовать ⁡⁣⁣⁢строковые значения⁡ в качестве индексов для доступа к свойствам объекта.
// ⁡⁢⁣⁣Числовые индексы⁡: Можно использовать ⁡⁣⁣⁢числовые значения⁡ в качестве индексов для доступа к свойствам объекта.

interface MyObject {
    [key: string]: number; // Строковые индексы: ⁡⁣⁣⁢ключ - строка⁡, ⁡⁣⁣⁢значение - число⁡ /
}
const object: MyObject = {
    prop1: 1,
    prop2: 2,
};
console.log(object.prop1); // Выводит 1 // 
console.log(object['prop2']); // Выводит 2

// ⁡⁢⁣⁣Индексируемые типы⁡ (Index Types):
// ⁡⁢⁣⁣keyof⁡: Можно использовать ⁡⁣⁣⁢ключи объекта⁡ для получения ⁡⁣⁣⁢⁡⁣⁢⁣типа⁡ ⁡⁡⁣⁣⁢свойства по ключу⁡.
// ⁡⁢⁣⁣T[K]⁡: Можно использовать тип ⁡⁣⁣⁢K⁡ для получения ⁡⁣⁣⁡⁣⁢⁣типа⁡ ⁡⁣⁣⁢значения свойства⁡⁡ ⁡⁢⁣⁣K⁡ объекта типа ⁡⁢⁣⁣T⁡.

interface MyObject2 {
    prop1: number;
    prop2: string;
}
const object2: MyObject2 = {
    prop1: 1,
    prop2: 'Hello',
};
  
type Keys = keyof MyObject2; // Keys будет иметь тип 'prop1' | 'prop2' /
type ValueOfProp1 = MyObject2['prop1']; // ValueOfProp1 будет иметь тип number /

const getProperty = (obj: MyObject2, key: keyof MyObject2) => {
    return obj[key];
}
  
console.log(getProperty(object2, 'prop1')); // Выводит 1
console.log(getProperty(object2, 'prop2')); // Выводит 'Hello'

  