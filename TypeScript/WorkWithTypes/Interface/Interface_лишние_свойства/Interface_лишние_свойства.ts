// В ⁡⁢⁣⁣TypeScript⁡, ⁡⁣⁣⁢если объект содержит дополнительные свойства⁡, которые ⁡⁣⁣⁢не были определены⁡ в ⁡⁢⁣⁣интерфейсе⁡, это приводит к ⁡⁢⁣⁢ошибке⁡. 

interface Extra  {
    name?: string,
    age?: number
}

const obj:Extra = {
    name: 'Max', 
    age: 33,
    // ⁡⁣⁢⁣lastName: 'Hmel'⁡ // ⁡⁢⁣⁣lastName⁡ выдаст ⁡⁢⁣⁢ошибку⁡ , так как его ⁡⁢⁣⁢не существует⁡ в ⁡⁢⁣⁣Extra⁡.
}

// Есть ⁡⁢⁣⁣три вариант решения⁡ этой ⁡⁢⁣⁢проблемы⁡ (⁡⁢⁣⁣индексная сигнатура⁡, ⁡⁢⁣⁣Присвоить объект другой переменной⁡, ⁡⁢⁣⁡⁢⁢⁢использовать⁡ ⁡⁢⁣⁣​‌‍‌as​⁡⁡) .

// ⁡⁣⁢⁣​‌‍‌1.⁡⁡​ Использование типа "⁡⁢⁣⁣индексной сигнатуры⁡" позволяет объекту ⁡⁣⁣⁢иметь произвольные дополнительные свойства⁡ любого типа ⁡⁣⁢⁣([key: string]: ⁡⁢⁣⁣any⁡⁣⁢⁣)⁡⁡. 
// Это означает, что ⁡⁢⁣⁣объект⁡ может ⁡⁢⁣⁣содержать⁡ свойства с ⁡⁣⁣⁢разными именами и типами данных⁡. 
interface Extra2 {
    name?: string,
    age?: number,
    [key: string]: any;
}
const obj2:Extra2 = {
    name: 'Max', 
    age: 34,
    lastName: 'Hmel'
}
console.log(obj2);


// ⁡⁣⁢⁣​‌‍‌2.⁡⁡​ ⁡⁢⁣⁣Присвоить объект другой переменной⁡. Из-за присваивания объекта другой переменной он не будет проходить ⁡⁣⁣⁢проверку⁡ на ⁡⁢⁣⁣избыточные свойства⁡, компилятор не выдаст ⁡⁢⁣⁢ошибки⁡.
interface Extra3 {
    name?: string,
    age?: number,
}
const obj3 = {
    name: 'Max', 
    age: 35,
    lastName: 'Hmel'
}
let msa:Extra3 = obj3
console.log(obj3);

// ⁡⁣⁢⁣3.⁡ ⁡⁣⁣⁢Использование приведение типов⁡ ключевым слово ​‌‍‌⁡⁢⁣⁣as⁡​:
interface Extra4 {
    name?: string,
    age?: number,
}
const obj4 = {
    name: 'Max', 
    age: 72,
    lastName: 'Hmel'
} as Extra4
console.log(obj4);
