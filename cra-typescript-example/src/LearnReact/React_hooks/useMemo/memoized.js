export {};
// ⁡⁢⁣⁣Мемоизированное значение⁡ в контексте - это значение, которое было ⁡⁣⁣⁢кэшировано⁡ и будет возвращено из кэша, 
// если аргументы (зависимости) функции ⁡⁣⁣⁢не изменились⁡ с момента последнего вычисления.

// ⁡⁣⁢⁢const⁡ ⁡⁣⁢⁣memoizedValue⁡ ⁡⁣⁣⁢=⁡ ⁡⁢⁣⁣useMemo⁡⁣⁣⁢(() =>⁡ ⁡⁢⁣⁣computeExpensiveValue⁡⁣⁣⁢(⁡⁣⁢⁣a⁡⁡⁣⁣⁢,⁡ ⁡⁣⁢⁣b⁡⁡⁣⁣⁢),⁡ ⁡⁣⁣⁢[⁡⁣⁢⁣a⁡,⁡ ⁡⁣⁢⁣b⁡⁡⁣⁣⁢])⁡;

// В этом примере ⁡⁢⁣⁣computeExpensiveValue(a, b)⁡ - это функция, которая выполняет какие-то вычисления на основе аргументов ⁡⁣⁢⁣a⁡ и ⁡⁣⁢⁣b⁡. 
// Значение ⁡⁢⁣⁣memoizedValue⁡ будет ⁡⁣⁣⁢мемоизированным значением⁡.
// При первом вызове ⁡⁣⁣⁢useMemo⁡, он выполнит ⁡⁢⁣⁣computeExpensiveValue(a, b)⁡ и ⁡⁣⁣⁢вернет результат вычислений⁡. 
// При этом аргументы [a, b] записываются как зависимости.

// Если при ⁡⁣⁣⁢следующем рендере⁡ компонента значения ⁡⁣⁣⁢a⁡ и ⁡⁣⁣⁢b⁡ ⁡⁣⁢⁣не изменились⁡, ⁡⁢⁣⁣useMemo⁡ просто ⁡⁣⁣⁢вернет мемоизированное значение из своего кэша⁡, и 
// ⁡⁢⁣⁣computeExpensiveValue(a, b)⁡ ⁡⁢⁣⁢не будет⁡ вызываться снова. Это экономит ресурсы, так как вычисления могут быть дорогими с точки зрения 
// производительности.
