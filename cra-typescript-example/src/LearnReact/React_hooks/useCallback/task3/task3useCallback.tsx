// Задача 3: Использование useCallback с useEffect
// Создайте приложение, которое рендерит список элементов. У вас есть кнопка, которая добавляет новый элемент в список.
//  У вас также есть эффект, который следит за изменением списка и выводит сообщение в консоль при каждом изменении.
//  Ваша задача - использовать useCallback в сочетании с useEffect для оптимизации этого процесса.

import React from "react";


export const Task3UseCallback = () => {

  const [arr, setArr] = React.useState<number[]>([])

  const [list, setList] = React.useState(0);

  const setListItem = React.useCallback(() => {
    setList(prev => prev + 1)
  },[])

React.useEffect(() => {
  const newArr = []
  for(let i = 0; i<=list; i++ ){
    newArr.push(i) // так нельзя было сделать setArr([...arr, i]), читать ниже почему .
  }
  setArr(newArr)
},[list])

  return <div>
    {arr?.map((_item, key) => <li key={key}>{_item}</li>)}
  <button onClick={setListItem}>Plus item</button>
  </div>
} 

// в React и в целом при работе с JavaScript ⁡⁢⁣⁢нежелательно⁡ ⁡⁣⁣⁢менять состояние внутри циклов⁡. Это связано с несколькими проблемами:

// ⁡⁣⁢⁣1⁡ ⁡⁢⁣⁣Производительность⁡: Когда вы меняете состояние в React, это может вызвать перерисовку компонента. Если вы делаете это в цикле, 
// это ⁡⁣⁣⁢может вызвать множественные перерисовки⁡, что может замедлить ваше приложение.

// ⁡⁣⁢⁣2⁡ ⁡⁢⁣⁣Непредсказуемость⁡: Из-за ⁡⁣⁣⁢асинхронности⁡ обновления состояния в React, состояние может не обновиться мгновенно после вызова setState. 
// Это означает, что если вы вызываете setState в цикле, вы можете столкнуться с ситуацией, когда состояние не обновляется так, как вы ожидаете.

// ⁡⁣⁢⁣3⁡ ⁡⁢⁣⁣Побочные эффекты⁡: Если ваше состояние влияет на другие части приложения (например, вызывает побочные эффекты в useEffect), 
// обновление состояния в цикле может привести к неожиданным результатам.

// Вместо обновления состояния в цикле, лучше создать новое значение за пределами цикла, 
// а затем установить это значение как новое состояние один раз после завершения цикла.