// ⁡⁢⁣⁣Замыкание⁡ — это комбинация функции и лексического окружения, в котором эта функция была определена. 
// ⁡⁣⁣⁢​‌‍‌Другими словами​⁡, замыкание даёт вам доступ к ⁡⁢⁣⁣Scope⁡ (⁡⁢⁣⁣лексическому окружению⁡) внешней функции из внутренней функции. 
// В JavaScript замыкания создаются ⁡⁣⁣⁢каждый раз при создании функции⁡, во время её создания.

function Counter() {
    let count = 0 ;
    return function () {  // Вот эта функция ⁡⁣⁣⁢замкнута на области видимости родителя⁡.
        count++
        return count
    }
}
// Все функции «⁡⁢⁣⁣при рождении⁡» получают скрытое свойство ⁡⁢⁣⁢[[Environment]]⁡, 
// которое ссылается на ⁡⁣⁣⁢лексическое окружение⁡ места, где они были созданы.

// Другими словами, функция ⁡⁢⁣⁣навсегда запоминает⁡ ссылку на лексическое окружение, 
// где она была создана. И ⁡⁢⁣⁢[[Environment]]⁡ – скрытое свойство функции, которое содержит эту ⁡⁣⁣⁢ссылку⁡.

// ⁡⁢⁢⁣​‌‍‌Вопрос на собеседовании⁡⁡​ - правильным ответом будет определение замыкания и объяснения того факта, 
// что ⁡⁣⁣⁢все функции в JavaScript являются ⁡⁢⁣⁣замыканиями⁡⁡, и, может быть, 
// несколько слов о технических деталях: свойстве ⁡⁢⁣⁣[[Environment]]⁡ и о том, как работает ⁡⁢⁣⁣лексическое окружение⁡.

// ​‌‍‌⁡⁣⁣⁢IF⁡​  / 
// В следующем примере переменная ⁡⁢⁣⁣user⁡ существует только в блоке ⁡⁢⁣⁣if⁡:
let phrase = 'Hello';
if(true){
    let user = 'John';
    console.log(`${phrase} + ${user}`)
}
// ⁡⁣⁢⁢console.log⁡(⁡⁣⁢⁣user⁡) // Error. ⁡⁢⁣⁣user⁡ существует только в блоке ⁡⁢⁣⁣if⁡ /

// ​‌‍‌⁡⁣⁣⁢For, while⁡​ /
// Для ⁡⁢⁣⁣цикла⁡ у каждой итерации ⁡⁣⁣⁢своё отдельное лексическое окружение⁡. 
// Если переменная объявлена в ⁡⁢⁣⁣for(let ...)⁡, то она также в нём:

for (let i = 0; i < 10; i++) {
    // У каждой итерации цикла ⁡⁣⁣⁢своё собственное лексическое окружение⁡ /
    // ⁡⁣⁣⁢{i: value}⁡ /
  }

// ​‌‍‌⁡⁣⁣⁢Блоки кода⁡​ /
// Мы также можем использовать «простые» блоки кода ⁡⁢⁣⁣{...}⁡, 
// чтобы ⁡⁢⁣⁣изолировать⁡ переменные в «⁡⁣⁣⁢локальной области видимости⁡».
let block = 'first'
{
    let block = 'second'
    console.log(block) // Result: 'second' /
}

//​‌‍‌⁡⁣⁣⁢ IIFE (immediately-invoked function expressions) ⁡​/

// «⁡⁢⁣⁣immediately-invoked function expressions⁡» (аббревиатура ⁡⁢⁣⁣IIFE⁡), 
// что означает функцию, ⁡⁣⁣⁢запускаемую сразу после объявления⁡.

// ⁡⁢⁣⁣Cкобки вокруг функции ⁡⁣⁣⁢(function {...})⁡⁡ – это трюк, который позволяет показать JavaScript, 
// что функция была создана в контексте ⁡⁣⁣⁢другого⁡ выражения, и, таким образом, 
// это функциональное выражение: ⁡⁣⁣⁢ей не нужно⁡ имя и её можно вызвать немедленно.

(function() {
    let message = "Hello";
    console.log(message); // Hello
})();
