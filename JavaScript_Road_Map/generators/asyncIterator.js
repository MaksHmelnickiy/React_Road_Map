// ⁡⁢⁣⁣«Обычный» перебираемый объект⁡, как подробно рассказано в главе Перебираемые объекты, выглядит примерно так:

let iterator = {
    from: 1,
    to: 5
} 

// ⁡⁢⁣⁣for..of⁡ что ниже (⁡⁣⁢⁣29 строка⁡)⁡ вызывает этот метод один раз в самом начале
iterator[Symbol.iterator] = function(){ 
    // ...возвращает ⁡⁢⁣⁣объект-итератор⁡:
    // далее ⁡⁢⁣⁣for..of⁡ работает только ⁡⁣⁣⁢с этим объектом⁡, запрашивая следующее значение вызовом ⁡⁢⁣⁣next()⁡ /
    return {
        current: this.from,
        last: this.to,
        // ⁡⁢⁣⁣next()⁡ вызывается на каждой итерации цикла ⁡⁣⁣⁢for..of⁡ .
        next(){
            // должен возвращать значение в виде объекта ⁡⁣⁢⁣{done:.., value :...}⁡ .
            if(this.current <= this.last){
                return {
                    done: false,
                    value: this.current++
                }
            }
            else {
                return {done:true}
            }
        }
    }
}

for(let item of iterator ){
    console.log(item) // 1, потом 2, потом 3, потом 4, потом 5
}

// Давайте создадим итерируемый объект ⁡⁢⁣⁣range⁡, как и ⁡⁣⁣⁢в предыдущем примере⁡, но теперь он будет возвращать ⁡⁢⁣⁣значения асинхронно⁡, по одному в секунду:

let range = {
    from: 1,
    to: 10
}

// ⁡⁢⁣⁣for await..of⁡ вызывает этот метод ⁡⁣⁣⁢один раз⁡ в самом начале
range[Symbol.asyncIterator] = function(){
    // ...возвращает объект-итератор:
    // далее ⁡⁢⁣⁣for await..of⁡ работает ⁡⁣⁣⁢только с этим объектом⁡,
    // запрашивая у него ⁡⁣⁣⁢следующие значения⁡ вызовом ⁡⁢⁣⁣next()⁡ /
    return {
        start: this.from,
        finish: this.to,
        // ⁡⁢⁣⁣next()⁡ вызывается ⁡⁣⁣⁢на каждой итерации цикла⁡ ⁡⁢⁣⁣for await..of⁡⁡ /
        async next(){
            // должен возвращать значение как объект ⁡⁣⁢⁣{done:.., value :...}⁡
            // (автоматически ⁡⁢⁣⁣оборачивается в промис⁡ с помощью async)

            // можно использовать ⁡⁢⁣⁣await⁡ ⁡⁣⁣⁢внутри для асинхронности⁡:
            await new Promise(resolve => setTimeout(resolve, 1000))
            if(this.start <= this.finish){
                
                return {done: false, value: this.start++}
            }
            else{
                return {done: true}
            }
        },
    };
};

(async () => {
    for await(let i of range){
        console.log(i) // 1,2,3,4,5
    }
})()

// ⁡⁣⁣⁢Оператор расширения ⁡⁢⁣⁣...⁡​‌‍‌⁡⁢⁣⁢ не работает⁡​ ⁡⁣⁣⁢асинхронно⁡.  Ему ⁡⁢⁣⁢не подходит⁡ ⁡⁢⁣⁣Symbol.asyncIterator⁡.
alert( [...range] ); // ⁡⁢⁣⁢Uncaught TypeError⁡: range is not iterable /

// ​‌‌‍⁡⁣⁣⁢Небольшая шпаргалка⁡​ .           
//                                              ⁡⁢⁣⁣Итераторы⁡⁡             ⁡⁢⁢⁡⁢⁣⁣Асинхронные итераторы⁡⁡
// ⁡⁢⁢⁢Метод для создания итерируемого объекта⁡   ⁡⁢⁣⁢|⁡⁡⁡  ⁡⁣⁢⁣Symbol.iterator⁡   ⁡⁢⁣⁢|⁡⁡⁡   ⁡⁣⁢⁣Symbol.asyncIterator⁡
// ⁡⁢⁢⁡⁣⁣⁢next()⁡ ⁡⁢⁢⁢возвращает⁡⁡                         ⁡⁢⁣⁢|⁡⁡⁡  ⁡⁣⁢⁣любое значение⁡    ⁡⁢⁣⁢|⁡⁡⁡   ⁡⁣⁢⁣промис⁡ 
//⁡⁢⁢⁢ для цикла используйте⁡                     ⁡⁢⁣⁢|⁡⁡⁡  ⁡⁣⁢⁣for..of⁡           ⁡⁣⁢⁡⁢⁢⁡⁢⁣⁢|⁡⁡⁡   ⁡⁣⁢⁣for await..of⁡ 