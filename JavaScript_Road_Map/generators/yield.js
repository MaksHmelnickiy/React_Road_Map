// ⁡⁢⁣⁣yield⁡ – дорога в обе стороны: он не только возвращает результат наружу, но и может 
// ⁡⁣⁣⁢передавать значение извне в ⁡⁢⁣⁣генератор⁡⁡.
// Чтобы это сделать, нам нужно вызвать ⁡⁣⁣⁢generator.next(arg)⁡ с ⁡⁣⁣⁡⁣⁢⁣аргументом⁡⁡. Этот аргумент становится результатом ⁡⁢⁣⁣yield⁡.

function* gen() {
    // Передаём вопрос во внешний код и ожидаем ответа
    let result = (yield) * 2; // (*)
  
    console.log(result);
  }
  
  let generator = gen();
  
  generator.next(); // <--⁡⁢⁣⁣ yield⁡ возвращает значение // первый вызов ⁡⁢⁣⁣.next()⁡ - типа ⁡⁣⁣⁢запускает генератор⁡. 
  
  generator.next(4); // --> передаём результат в генератор

//  Как видно, в отличие от обычных функций, 
// ⁡⁢⁣⁣ Внешний код⁡ и ⁡⁢⁣⁣генератор⁡ ⁡⁣⁣⁢обмениваются промежуточными результатами⁡ посредством вызовов ⁡⁢⁣⁣next/yield⁡.

// ​‌‍‌⁡⁣⁣⁢generator.throw⁡​⁡ /
// Чтобы передать ⁡⁢⁣⁢ошибку⁡ в ⁡⁢⁣⁣yield⁡, нам нужно вызвать ⁡⁢⁣⁣generator.throw(err)⁡. 
// В таком случае исключение err возникнет на строке с yield. 

function* genErr() {
    try {
      let result = yield "2 + 2 = ?"; // (1)
      console.log("Выполнение программы не дойдёт до этой строки, потому что выше возникнет исключение");
    } catch(e) {
      console.log(e); // покажет ошибку
    }
}
  
  let generatorErr = genErr();
  
  let questionErr = generatorErr.next().value;
  
  generatorErr.throw(new Error("Ответ не найден в моей базе данных")); // (2)   // для отлова ошибок мы должны использовать ⁡⁢⁣⁣.throw()⁡ .