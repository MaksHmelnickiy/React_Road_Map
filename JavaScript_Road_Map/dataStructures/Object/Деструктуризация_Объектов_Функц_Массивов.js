// ⁡⁢⁣⁣Деструктурирующее присваивание⁡ – это специальный синтаксис, который позволяет нам «⁡⁣⁣⁢распаковать⁡» 
// ⁡⁢⁣⁢массивы⁡⁡, ⁡⁢⁣⁢функции⁡ или ⁡⁢⁣⁢объекты⁡ в несколько переменных, так как иногда они более удобны.

// ⁡⁣⁢⁣​‌‍‌​‌‌‍Деструктуризация объекта⁡​⁡​ /
// Синтаксис: /

let {v,d} = {v: 'test', d: 'test2'}; // Названия переменных с ⁡⁣⁣⁢левой стороны⁡ должны ⁡⁢⁣⁣совпадать⁡ с ключами в объекте ⁡⁣⁣⁢с правой⁡ /
console.log('v',v)

let options = {
    title: "Menu",
    width: 100,
    height: 200
  };
  
let {title, width, height} = options; // Мы как бы ⁡⁢⁣⁣копируем объект⁡ разбивая его на переменные.
options.title = "se" 
console.log('options', options) // ⁡⁣⁢⁣options.title⁡ = ⁡⁣⁣⁢"se"⁡ так как мы ⁡⁢⁣⁣перезаписали⁡ значение для ключа.
console.log(title);  // Menu    // А здесь уже ⁡⁣⁢⁣title⁡ будет равно ⁡⁣⁣⁢"Menu"⁡ так как ⁡⁢⁣⁣копирование произошло раньше⁡, 
                                // и только потом мы перезаписали его на ⁡⁣⁣⁢"se"⁡/ 
console.log(width);  // 100
console.log(height); // 200

// ⁡⁣⁣⁢​‌‍​‌‍‌Порядок не имеет значения⁡, вот так тоже ⁡⁢⁣⁣работает​⁡⁡:
// изменён порядок в let {...}
let {height2, width2, title2} = { title2: "Menu", height2: 200, width2: 100 }
console.log(title2) // Menu


// ​‌‍‌Если у нас ⁡⁣⁣⁢есть большой объект⁡ с множеством свойств, можно ⁡⁢⁣⁣взять⁡ только то, что нужно​:
let options3 = {
    title3: "Menu",
    width3: 100,
    height3: 200,
  //size: 400,
  //...
};
  
let { title3 } = options3; // взять только title3, игнорировать остальное /
console.log(title3); // Menu

// ⁡⁣⁣⁢​‌‍‌Остаток объекта «⁡⁢⁣⁣…⁡»​⁡    /

let options4 = {
  title: "Menu3",
  height: 200,
  width: 100
};

// title = свойство с именем title
// ⁡⁢⁣⁣rest⁡ = ⁡⁣⁣⁢объект с остальными свойствами⁡ /
let {title4, ...rest} = options4;

// сейчас title="Menu", ⁡⁣⁢⁡⁢⁣⁢rest={height: 200, width: 100}⁡⁡ /
console.log('...',rest.height);  // 200
console.log('...',rest.width);   // 100


// ​‌‌‍⁡⁣⁢⁣‍⁡⁢⁢⁣‍⁡⁣⁣⁡⁣⁢⁣Деструктуризация массива⁡⁡⁡⁡⁡ пример​​:​ /

// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"];
// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [firstName, surname] = arr;
arr[0]="sss"
console.log(firstName); // Ilya
console.log(surname);  // Kantor

// Аналогичным способом можно разбить строку методом ⁡⁢⁣⁣split⁡ или другими методам /
let [firstName2, surname2] = "Ilya Kantor".split(' ');
console.log(firstName2); // Ilya
console.log(surname2);  // Kantor

// «⁡⁢⁣⁣Деструктурирующее присваивание⁡» не уничтожает массив. Оно вообще ничего не делает 
// с правой частью присваивания, его задача – только ⁡⁣⁣⁢скопировать⁡ нужные значения в переменные.

// ⁡⁣⁣⁢Это просто короткий вариант записи⁡:
// let [firstName, surname] = arr;
let firstName3 = arr[0];
let surname3 = arr[1];

// Работает с любым ⁡⁢⁣⁣перебираемым объектом⁡ с правой стороны
// …На самом деле мы можем использовать любой перебираемый объект, не только массивы:
let [a, b, c] = "abc";
let [one, two, three] = new Set([1, 2, 3]);


// ​‌‌‍⁡⁣⁢⁣Деструктуризация Функций⁡​ /

// Есть ситуации, когда ⁡⁣⁣⁢функция имеет много параметров⁡, большинство из которых ⁡⁣⁣⁢не обязательны⁡. 
// Это особенно верно для пользовательских интерфейсов.
// На помощь приходит ⁡⁢⁣⁣деструктуризация⁡!
// Мы можем передать ⁡⁣⁣⁢параметры как объект⁡, и функция немедленно деструктурирует его в переменные:

// мы передаём объект в функцию /
let options5 = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...и она немедленно извлекает свойства в переменные
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – взято из options,
  // width, height – используются значения по умолчанию
  console.log( `${title} ${width} ${height}` ); // My Menu 200 100
  console.log( items ); // Item1, Item2
}

showMenu(options5);
