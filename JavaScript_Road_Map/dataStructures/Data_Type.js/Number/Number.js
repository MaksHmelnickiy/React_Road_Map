// В современном ⁡⁢⁣⁣JavaScript⁡ существует ⁡⁣⁣⁢два типа чисел⁡: Обычные числа типа ⁡⁣⁢⁡⁢⁣⁣number⁡⁡  и ⁡⁢⁣⁣BigInt⁡⁡ /
// ⁡⁢⁣⁣BigInt⁡ – это специальный числовой тип, который предоставляет возможность работать с ⁡⁣⁣⁢целыми числами произвольной длины⁡.
const bigint = 1234567890123456789012345678901234567890n; // в конце добавляем ⁡⁢⁣⁣n⁡ или ⁡⁢⁣⁣BigInt(...)⁡ /

// В JavaScript можно использовать букву ⁡⁢⁣⁣"e"⁡, чтобы укоротить запись числа. Она добавляется к числу 
// и заменяет указанное количество нулей:

let billion = 7e9;
console.log(billion)

let ms = 1e-6; // шесть нулей, слева от 1 ,  0.000001; 1 микросекунда

let num = 1.23456;
console.log( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23 // Округляет до 2 цифры после запятой


// Метод ⁡⁢⁣⁣toFixed(n)⁡ округляет число до n знаков после запятой и возвращает строковое представление результата.
let num2 = 12.343132;
console.log( num2.toFixed(2)) // Резульатом будет ⁡⁣⁡⁣⁢⁣12.34


// ⁡⁢⁣⁣Infinity (и -Infinity)⁡⁡⁡⁡ — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.
// ⁡⁢⁣⁣NaN⁡ - специальное значение "⁡⁢⁣⁣не число⁡", которое обычно говорит о том, что была выполнена бессмысленная операция.

// ⁡⁢⁣⁣isNaN(value)⁡ преобразует значение в число и проверяет является ли оно NaN:
console.log('isNan', isNaN(NaN) ); // true
console.log('isNan', isNaN('string') ); // true

// Нужна ли нам эта функция? Разве не можем ли мы просто сравнить ⁡⁢⁣⁣=== NaN ⁡? 
// К сожалению, нет. Значение ⁡⁢⁣⁣NaN⁡ уникально тем, ⁡⁢⁣⁢что оно не является равным ни чему другому, даже самому себе⁡:
console.log(NaN === NaN); // false


// Функция ⁡⁢⁣⁣Number.isFinite()⁡ проверяет, является ли переменная числом, но также проверяет, является ли это конечным значением. 
// Следовательно, он возвращает ⁡⁢⁣⁢false⁡ для чисел ⁡⁣⁢⁣NaN , Infinity⁡ или ⁡⁣⁢⁣-Infinity⁡ .

// Существует специальный метод ⁡⁢⁣⁣Object.is⁡, который сравнивает значения примерно как ===, 
// но более надёжен в двух особых ситуациях:
// Работает с ⁡⁢⁣⁣NaN⁡: ⁡⁢⁣⁢Object.is(NaN, NaN) === true⁡, здесь он хорош.
// Значения ⁡⁣⁢⁣0⁡⁡ и ⁡⁣⁢⁣-0⁡⁡ разные: ⁡⁢⁣⁢Object.is(0, -0) === false⁡, это редко используется, но технически эти значения разные.
// Во всех других случаях ⁡⁢⁣⁣Object.is(a, b)⁡ идентичен ⁡⁢⁣⁢a === b⁡.

// ⁡⁢⁣⁣parseInt и parseFloat⁡. ⁡⁣⁣⁢Они «читают» число из строки⁡. Если в процессе чтения ⁡⁣⁣⁢возникает ошибка⁡,
// они ⁡⁣⁣⁢возвращают⁡ полученное до ошибки число. 

// Функция ⁡⁢⁣⁣parseInt⁡ возвращает целое число, а ⁡⁢⁣⁣parseFloat⁡ возвращает число с плавающей точкой:⁡
console.log('parseInt', parseInt('100px') ); // 100
console.log('parseFloat', parseFloat('12.5em') ); // 12.5
console.log('parseInt', parseInt('12.3') ); // 12, вернётся только целая часть
console.log('parseFloat', parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
console.log('parseInt result NaN', parseInt('a123') ); // ⁡⁢⁣⁢NaN⁡, на первом символе происходит остановка чтения


// ⁡⁣⁣⁢Задачи⁡ ..
console.log('Задачи')

let calc = {
    result: 0,
    plus(){
      let a = +prompt() // ⁡⁣⁣⁢+⁡ унарный оператор который переводит строку в число
      let b = +prompt() // ⁡⁣⁣⁢+⁡ унарный оператор который переводит строку в число
      return this.result = a + b
    }
}
calc.plus()
console.log('Задача1', calc.result)