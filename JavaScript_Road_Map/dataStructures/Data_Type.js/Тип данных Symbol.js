// Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

// По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. 
// Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.

// При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:
// Создаём символ id с описанием (именем) "id"
// Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами.
let id = Symbol("id");
// alert(id); // Выдаст ошибку так как символ это особенные значения и автоматически не пробразует в строку. TypeError: Cannot convert a Symbol value to a string

// Если же мы действительно хотим вывести символ с помощью alert, то необходимо явно преобразовать его с помощью метода .toString(), вот так:
alert(String(id))

// Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.
// Например, мы работаем с объектами user, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы.
// Используем для этого символьный ключ:
let user ={
    name: 'Vasya'
}
let id2 = Symbol('id');
user[id2] = 1
console.log(user[id2])

// Почему же лучше использовать Symbol("id"), а не строку "id"?
// Так как объект user принадлежит стороннему коду, и этот код также работает с ним, то нам не следует добавлять к нему какие-либо поля. 
// Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд ли его вообще увидит, и, скорее всего, добавление поля к объекту не вызовет никаких проблем.


// Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.
// Вот так:

let id3 = Symbol("id");

let user2 = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};

// Символы игнорируются циклом for…in, Object.keys(user) также игнорирует символы.
// А вот Object.assign работает копирует и строковые, и символьные свойства:
let clone = Object.assign({}, user2);
alert( clone[id] ); // 123

// Для чтения (или, при отсутствии, создания) символа из реестра используется вызов Symbol.for(key).
let id4 = Symbol.for("id"); // если символа не существует, он будет создан
// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id4 === idAgain ); // true


// Для глобальных символов, кроме Symbol.for(key), 
// который ищет символ по имени, существует обратный метод: Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id